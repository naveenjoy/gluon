
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
import numpy as np
from bitarray import bitarray
class yc_binding_information_gluon_port__gluon_port_binding_information(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module gluon-port - based on the path /gluon-port/binding-information. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__vnic_type','__host_id',)

  _yang_name = 'binding-information'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__host_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="host_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__vnic_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'PCI-full-device': {}, u'direct': {}, u'sriov': {}, u'macvtap': {}},), is_leaf=True, yang_name="vnic-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='enumeration')

    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        setmethod(getattr(args[0], e))

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'gluon-port', u'binding-information']

  def _get_vnic_type(self):
    """
    Getter method for vnic_type, mapped from YANG variable /gluon_port/binding_information/vnic_type (enumeration)
    """
    return self.__vnic_type
      
  def _set_vnic_type(self, v, load=False):
    """
    Setter method for vnic_type, mapped from YANG variable /gluon_port/binding_information/vnic_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnic_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnic_type() directly.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'PCI-full-device': {}, u'direct': {}, u'sriov': {}, u'macvtap': {}},), is_leaf=True, yang_name="vnic-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='enumeration')
    except (TypeError, ValueError):
      raise ValueError("""vnic_type must be of a type compatible with base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'PCI-full-device': {}, u'direct': {}, u'sriov': {}, u'macvtap': {}},), is_leaf=True, yang_name="vnic-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='enumeration'""")
    self.__vnic_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnic_type(self):
    self.__vnic_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'PCI-full-device': {}, u'direct': {}, u'sriov': {}, u'macvtap': {}},), is_leaf=True, yang_name="vnic-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='enumeration')


  def _get_host_id(self):
    """
    Getter method for host_id, mapped from YANG variable /gluon_port/binding_information/host_id (string)
    """
    return self.__host_id
      
  def _set_host_id(self, v, load=False):
    """
    Setter method for host_id, mapped from YANG variable /gluon_port/binding_information/host_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_id() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="host_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""host_id must be of a type compatible with base=unicode, is_leaf=True, yang_name="host_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__host_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_id(self):
    self.__host_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="host_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')

  vnic_type = property(_get_vnic_type, _set_vnic_type)
  host_id = property(_get_host_id, _set_host_id)


  _pyangbind_elements = {'vnic_type': vnic_type, 'host_id': host_id, }


class yc_addressing_gluon_port__gluon_port_addressing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module gluon-port - based on the path /gluon-port/addressing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__ipaddress','__gateway','__subnet_prefix',)

  _yang_name = 'addressing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__subnet_prefix = YANGDynClass(base=unicode, is_leaf=True, yang_name="subnet-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__ipaddress = YANGDynClass(base=unicode, is_leaf=True, yang_name="ipaddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__gateway = YANGDynClass(base=unicode, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')

    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        setmethod(getattr(args[0], e))

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'gluon-port', u'addressing']

  def _get_ipaddress(self):
    """
    Getter method for ipaddress, mapped from YANG variable /gluon_port/addressing/ipaddress (string)
    """
    return self.__ipaddress
      
  def _set_ipaddress(self, v, load=False):
    """
    Setter method for ipaddress, mapped from YANG variable /gluon_port/addressing/ipaddress (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipaddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipaddress() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ipaddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""ipaddress must be of a type compatible with base=unicode, is_leaf=True, yang_name="ipaddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__ipaddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipaddress(self):
    self.__ipaddress = YANGDynClass(base=unicode, is_leaf=True, yang_name="ipaddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_gateway(self):
    """
    Getter method for gateway, mapped from YANG variable /gluon_port/addressing/gateway (string)
    """
    return self.__gateway
      
  def _set_gateway(self, v, load=False):
    """
    Setter method for gateway, mapped from YANG variable /gluon_port/addressing/gateway (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""gateway must be of a type compatible with base=unicode, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway(self):
    self.__gateway = YANGDynClass(base=unicode, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_subnet_prefix(self):
    """
    Getter method for subnet_prefix, mapped from YANG variable /gluon_port/addressing/subnet_prefix (string)
    """
    return self.__subnet_prefix
      
  def _set_subnet_prefix(self, v, load=False):
    """
    Setter method for subnet_prefix, mapped from YANG variable /gluon_port/addressing/subnet_prefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet_prefix() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="subnet-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""subnet_prefix must be of a type compatible with base=unicode, is_leaf=True, yang_name="subnet-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__subnet_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnet_prefix(self):
    self.__subnet_prefix = YANGDynClass(base=unicode, is_leaf=True, yang_name="subnet-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')

  ipaddress = property(_get_ipaddress, _set_ipaddress)
  gateway = property(_get_gateway, _set_gateway)
  subnet_prefix = property(_get_subnet_prefix, _set_subnet_prefix)


  _pyangbind_elements = {'ipaddress': ipaddress, 'gateway': gateway, 'subnet_prefix': subnet_prefix, }


class yc_gluon_port_gluon_port__gluon_port(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module gluon-port - based on the path /gluon-port. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__id','__owner','__mac_address','__admin_state_up','__status','__binding_information','__profile','__vif_details','__vif_type','__addressing','__vpn_instance_id','__mtu','__vlan_transparency','__tenant_id',)

  _yang_name = 'gluon-port'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=unicode, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__profile = YANGDynClass(base=unicode, is_leaf=True, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__vif_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="vif_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__admin_state_up = YANGDynClass(base=unicode, is_leaf=True, yang_name="admin-state-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__vif_details = YANGDynClass(base=unicode, is_leaf=True, yang_name="vif_details", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__binding_information = YANGDynClass(base=yc_binding_information_gluon_port__gluon_port_binding_information, is_container='container', yang_name="binding-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container')
    self.__addressing = YANGDynClass(base=yc_addressing_gluon_port__gluon_port_addressing, is_container='container', yang_name="addressing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container')
    self.__mtu = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='uint32')
    self.__vpn_instance_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="vpn-instance-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__tenant_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="tenant-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__vlan_transparency = YANGDynClass(base=unicode, is_leaf=True, yang_name="vlan-transparency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__mac_address = YANGDynClass(base=unicode, is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__owner = YANGDynClass(base=unicode, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    self.__id = YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')

    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        setmethod(getattr(args[0], e))

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'gluon-port']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /gluon_port/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /gluon_port/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""id must be of a type compatible with base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_owner(self):
    """
    Getter method for owner, mapped from YANG variable /gluon_port/owner (string)
    """
    return self.__owner
      
  def _set_owner(self, v, load=False):
    """
    Setter method for owner, mapped from YANG variable /gluon_port/owner (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_owner is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_owner() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""owner must be of a type compatible with base=unicode, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__owner = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_owner(self):
    self.__owner = YANGDynClass(base=unicode, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /gluon_port/mac_address (string)
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /gluon_port/mac_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""mac_address must be of a type compatible with base=unicode, is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=unicode, is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_admin_state_up(self):
    """
    Getter method for admin_state_up, mapped from YANG variable /gluon_port/admin_state_up (string)
    """
    return self.__admin_state_up
      
  def _set_admin_state_up(self, v, load=False):
    """
    Setter method for admin_state_up, mapped from YANG variable /gluon_port/admin_state_up (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_state_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_state_up() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="admin-state-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""admin_state_up must be of a type compatible with base=unicode, is_leaf=True, yang_name="admin-state-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__admin_state_up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_state_up(self):
    self.__admin_state_up = YANGDynClass(base=unicode, is_leaf=True, yang_name="admin-state-up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /gluon_port/status (string)
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /gluon_port/status (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""status must be of a type compatible with base=unicode, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=unicode, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_binding_information(self):
    """
    Getter method for binding_information, mapped from YANG variable /gluon_port/binding_information (container)
    """
    return self.__binding_information
      
  def _set_binding_information(self, v, load=False):
    """
    Setter method for binding_information, mapped from YANG variable /gluon_port/binding_information (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_binding_information is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_binding_information() directly.
    """
    try:
      t = YANGDynClass(v,base=yc_binding_information_gluon_port__gluon_port_binding_information, is_container='container', yang_name="binding-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container')
    except (TypeError, ValueError):
      raise ValueError("""binding_information must be of a type compatible with base=yc_binding_information_gluon_port__gluon_port_binding_information, is_container='container', yang_name="binding-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container'""")
    self.__binding_information = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_binding_information(self):
    self.__binding_information = YANGDynClass(base=yc_binding_information_gluon_port__gluon_port_binding_information, is_container='container', yang_name="binding-information", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container')


  def _get_profile(self):
    """
    Getter method for profile, mapped from YANG variable /gluon_port/profile (string)
    """
    return self.__profile
      
  def _set_profile(self, v, load=False):
    """
    Setter method for profile, mapped from YANG variable /gluon_port/profile (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""profile must be of a type compatible with base=unicode, is_leaf=True, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile(self):
    self.__profile = YANGDynClass(base=unicode, is_leaf=True, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_vif_details(self):
    """
    Getter method for vif_details, mapped from YANG variable /gluon_port/vif_details (string)
    """
    return self.__vif_details
      
  def _set_vif_details(self, v, load=False):
    """
    Setter method for vif_details, mapped from YANG variable /gluon_port/vif_details (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vif_details is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vif_details() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vif_details", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""vif_details must be of a type compatible with base=unicode, is_leaf=True, yang_name="vif_details", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__vif_details = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vif_details(self):
    self.__vif_details = YANGDynClass(base=unicode, is_leaf=True, yang_name="vif_details", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_vif_type(self):
    """
    Getter method for vif_type, mapped from YANG variable /gluon_port/vif_type (string)
    """
    return self.__vif_type
      
  def _set_vif_type(self, v, load=False):
    """
    Setter method for vif_type, mapped from YANG variable /gluon_port/vif_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vif_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vif_type() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vif_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""vif_type must be of a type compatible with base=unicode, is_leaf=True, yang_name="vif_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__vif_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vif_type(self):
    self.__vif_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="vif_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_addressing(self):
    """
    Getter method for addressing, mapped from YANG variable /gluon_port/addressing (container)
    """
    return self.__addressing
      
  def _set_addressing(self, v, load=False):
    """
    Setter method for addressing, mapped from YANG variable /gluon_port/addressing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addressing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addressing() directly.
    """
    try:
      t = YANGDynClass(v,base=yc_addressing_gluon_port__gluon_port_addressing, is_container='container', yang_name="addressing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container')
    except (TypeError, ValueError):
      raise ValueError("""addressing must be of a type compatible with base=yc_addressing_gluon_port__gluon_port_addressing, is_container='container', yang_name="addressing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container'""")
    self.__addressing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addressing(self):
    self.__addressing = YANGDynClass(base=yc_addressing_gluon_port__gluon_port_addressing, is_container='container', yang_name="addressing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container')


  def _get_vpn_instance_id(self):
    """
    Getter method for vpn_instance_id, mapped from YANG variable /gluon_port/vpn_instance_id (string)
    """
    return self.__vpn_instance_id
      
  def _set_vpn_instance_id(self, v, load=False):
    """
    Setter method for vpn_instance_id, mapped from YANG variable /gluon_port/vpn_instance_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_instance_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_instance_id() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vpn-instance-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""vpn_instance_id must be of a type compatible with base=unicode, is_leaf=True, yang_name="vpn-instance-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__vpn_instance_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_instance_id(self):
    self.__vpn_instance_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="vpn-instance-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /gluon_port/mtu (uint32)
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /gluon_port/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.
    """
    try:
      t = YANGDynClass(v,base=np.uint32, is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='uint32')
    except (TypeError, ValueError):
      raise ValueError("""mtu must be of a type compatible with base=np.uint32, is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='uint32'""")
    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='uint32')


  def _get_vlan_transparency(self):
    """
    Getter method for vlan_transparency, mapped from YANG variable /gluon_port/vlan_transparency (string)
    """
    return self.__vlan_transparency
      
  def _set_vlan_transparency(self, v, load=False):
    """
    Setter method for vlan_transparency, mapped from YANG variable /gluon_port/vlan_transparency (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_transparency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_transparency() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vlan-transparency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""vlan_transparency must be of a type compatible with base=unicode, is_leaf=True, yang_name="vlan-transparency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__vlan_transparency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_transparency(self):
    self.__vlan_transparency = YANGDynClass(base=unicode, is_leaf=True, yang_name="vlan-transparency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')


  def _get_tenant_id(self):
    """
    Getter method for tenant_id, mapped from YANG variable /gluon_port/tenant_id (string)
    """
    return self.__tenant_id
      
  def _set_tenant_id(self, v, load=False):
    """
    Setter method for tenant_id, mapped from YANG variable /gluon_port/tenant_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tenant_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tenant_id() directly.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tenant-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')
    except (TypeError, ValueError):
      raise ValueError("""tenant_id must be of a type compatible with base=unicode, is_leaf=True, yang_name="tenant-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string'""")
    self.__tenant_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tenant_id(self):
    self.__tenant_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="tenant-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='string')

  id = property(_get_id, _set_id)
  owner = property(_get_owner, _set_owner)
  mac_address = property(_get_mac_address, _set_mac_address)
  admin_state_up = property(_get_admin_state_up, _set_admin_state_up)
  status = property(_get_status, _set_status)
  binding_information = property(_get_binding_information, _set_binding_information)
  profile = property(_get_profile, _set_profile)
  vif_details = property(_get_vif_details, _set_vif_details)
  vif_type = property(_get_vif_type, _set_vif_type)
  addressing = property(_get_addressing, _set_addressing)
  vpn_instance_id = property(_get_vpn_instance_id, _set_vpn_instance_id)
  mtu = property(_get_mtu, _set_mtu)
  vlan_transparency = property(_get_vlan_transparency, _set_vlan_transparency)
  tenant_id = property(_get_tenant_id, _set_tenant_id)


  _pyangbind_elements = {'id': id, 'owner': owner, 'mac_address': mac_address, 'admin_state_up': admin_state_up, 'status': status, 'binding_information': binding_information, 'profile': profile, 'vif_details': vif_details, 'vif_type': vif_type, 'addressing': addressing, 'vpn_instance_id': vpn_instance_id, 'mtu': mtu, 'vlan_transparency': vlan_transparency, 'tenant_id': tenant_id, }


class gluon_port(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module gluon-port - based on the path /gluon-port. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__gluon_port',)

  _yang_name = 'gluon-port'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__gluon_port = YANGDynClass(base=yc_gluon_port_gluon_port__gluon_port, is_container='container', yang_name="gluon-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container')

    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        setmethod(getattr(args[0], e))

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_gluon_port(self):
    """
    Getter method for gluon_port, mapped from YANG variable /gluon_port (container)
    """
    return self.__gluon_port
      
  def _set_gluon_port(self, v, load=False):
    """
    Setter method for gluon_port, mapped from YANG variable /gluon_port (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gluon_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gluon_port() directly.
    """
    try:
      t = YANGDynClass(v,base=yc_gluon_port_gluon_port__gluon_port, is_container='container', yang_name="gluon-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container')
    except (TypeError, ValueError):
      raise ValueError("""gluon_port must be of a type compatible with base=yc_gluon_port_gluon_port__gluon_port, is_container='container', yang_name="gluon-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container'""")
    self.__gluon_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gluon_port(self):
    self.__gluon_port = YANGDynClass(base=yc_gluon_port_gluon_port__gluon_port, is_container='container', yang_name="gluon-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openstack.com/ns/gloun', defining_module='gluon-port', yang_type='container')

  gluon_port = property(_get_gluon_port, _set_gluon_port)


  _pyangbind_elements = {'gluon_port': gluon_port, }


